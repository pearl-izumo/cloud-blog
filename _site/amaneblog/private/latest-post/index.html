<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>コメントありがとうございます</title>
    <link rel="stylesheet" href="/assets/style.css">
</head>
<body>

    <header>
        <div class="header-content">
            <a class="logo-link">
                <img src="/assets/cloudblog_logo.png" alt="CLOUDBLOGロゴ" class="header-logo">
            </a>
        </div>
    </header>

    <div class="main-container">
        <article>
    <div id="notification-container"></div>
    <h1>コメントありがとうございます</h1>

    

    

    

    
        <p>投稿日: <span id="dynamic-post-date">（記録処理中...）</span></p>
    

    <div class="post-content">
        <p>　名も知らぬONCEのどなたか、コメントありがとうございます。</p>

<p>　「<span id="quoted-comment-content">…</span>」ですか、なるほど。<br />
　自分から訊いてみたものの、これを書いている今は、他人の想いに安易に「分かる」と共感してしまうのも違う気がしています。<br />
<br />
　ONCEの数だけ、TWICEとの人生があると思うので。<br />
<br />
　返事と共感に代えて、あの秋の日から思考を重ね、下書きとして残してあった私の想いを公開します。</p>

<hr />
<p style="font-size: 0.9rem; color: #888;">2025-10-31 23:15 最終更新</p>
<p>　文字通りの「永遠」を心から信じていたわけではない。<br />
　けれど、どこかで期待していたのだろう。TWICEが、今ある姿のまま永遠であってくれることを。<br />
<br />
　10周年という節目を通り過ぎながら、いつか訪れる「終わり」の輪郭が少し鮮明になったのを、ただの気のせいだと振り払えない気持ちになった。<br />
　これは、解散のような直接的な出来事や、活動の大きな変化が起こるという話ではない。<br />
　近い将来、あるいは、いま目の前にあるこの瞬間で、私の大好きなTWICEの活動がピークを迎えてしまうかもしれない、という意味での「終わり」だ。<br />
<br />
　TWICEがどんなに苦心してくれたとしても、カムバや公演のペースが落ちていくこと、つまり今と変わっていくことはどうしたって避けられない。<br />
　というよりも、ペースを落とすことが、TWICEが続くための正しさなのだろう。<br />
　しかしそれは、私の人生の彩りが失われていくという寂しさや恐怖と共にある。<br /></p>
<p style="text-align: center;">＊＊＊</p>
<p>　私には、東京ドームで出会った、歳下のONCEの知人がいる。<br />
　彼女の新鮮でまっすぐな熱狂は、眩しいくらいだ。<br />
　私のTWICEへの想いは、純粋な桃色の感情だったあの頃と比べて、良くも悪くも真紅に滲んでいるような気がした。<br />
<br />
　私には、大学生の頃に知り合った、ONCEだった友人がいる。<br />
　彼は、就活をして、社会に出て、忙しく働く中で、趣味をひとつ失ったようだった。<br />
　彼の人生も決して悪くないが、私が今抱えているこれほどの愛情が、白く色褪せていくかもしれない事実は恐ろしい。<br />
<br />
　TWICEが変わっていくのと同じように、私の感情も時間とともに変わっていく。<br />
　次に訪れる感情はわからないけれど、今ここにある大切な感情は永遠ではなくて、何かをきっかけに「終わり」を迎えるものなのだ。<br /></p>
<p style="text-align: center;">＊＊＊</p>
<p>　だから私は、今この瞬間を、TWICEのために注ぎ切ることにしよう。<br />
<br />
　なるべくイベントには参加する。<br />
　そのために無理をせずに済むよう、お金も時間も普段から使い方を考える。<br />
　ちゃんと運動もして、健康に気をつける。<br />
　こんな生き方、あの頃の私なら自分には似合わないと切り捨てていたけれど、今ならちゃんと向き合える。<br />
<br />
　映画の中の言葉を信じて、TWICEの未来には今は想像もつかないような「最高」を期待したい。<br />
　私だって、このままもっとTWICEのことが好きになれるはず。当たり前だ。<br />
　ただ、そうは言っても、未来がどうなるかなんてわからないから、幸せだと確信できる「今」を存分に刻みつけたい。<br />
　それが「永遠」と思えるほどに。<br /></p>
<p style="text-align: center;">＊＊＊</p>
<p>　ちょうどいいモットーを思いついた。<br />
　まずはきっと、こうやって生きていけばいいのだ。<br />
　何かを「好き」な気持ちは、私自身を損なうものではなく、私自身がより良く生きられる理由なのだから。<br /></p>

<p>　<strong>THIS IS FOR TWICE.</strong></p>

<hr />

    </div>

    <!-- <hr style="margin-top: 40px;"> -->
    
    <section id="comment-section">
        <h2>コメント</h2>

        

        <div id="comment-form-area">
            <p>システムを読み込み中...</p>
        </div>
        
        <div id="comment-history-area">
            <p style="color: #666;"></p>
        </div>

    </section>

    <div class="return-links-area">
        
        
        
        

        
            <a href="/amaneblog/private/index.html" class="return-link">非公開記事一覧に戻る &raquo;</a>
        
    </div>

</article>

<script>
    //const CURRENT_BLOG_PATH = "amaneblog";
    const BLOG_PATH = "amaneblog"; // 安全のためデフォルト値を再設定
    const CURRENT_PLAYER_ID = localStorage.getItem('arg_player_id') || 'unknown';
    const CURRENT_POST_SLUG = "system-response-log";
    const ENABLE_COMMENT_TRIGGER = "false" === 'true';

    const QUOTE_SLUG = "trigger-test";
    const QUOTED_COMMENT_KEY = `comment_content_${BLOG_PATH}_${QUOTE_SLUG}`;

    // キーにブログIDとスラッグを含めることで、記事ごとに状態を分離
    // 例: 'trigger_state_amaneblog_trigger-test'
    const FLAG_STATE_KEY = `trigger_state_${BLOG_PATH}_${CURRENT_POST_SLUG}`;
    // 例: 'comment_content_amaneblog_trigger-test'
    const COMMENT_CONTENT_KEY = `comment_content_${BLOG_PATH}_${CURRENT_POST_SLUG}`; 
    // 例: 'trigger_time_ms_amaneblog_trigger-test'
    const TRIGGER_TIME_MS_KEY = `trigger_time_ms_${BLOG_PATH}_${CURRENT_POST_SLUG}`;
    // 日付保存用のキーを定義
    const TRIGGER_DATE_KEY = `trigger_date_${BLOG_PATH}_${CURRENT_POST_SLUG}`;

    // 🔑 隠し記事のスラッグ判定用
    const HIDDEN_POST_SLUGS = ["system-response-log"]; // 単一のスラッグに限定
    const IS_HIDDEN_POST = HIDDEN_POST_SLUGS.includes(CURRENT_POST_SLUG);

    // ---------------------------------------------------
    // 🔑 コメントフォーム生成と表示
    // ---------------------------------------------------
    
    function renderCommentForm() {
        const formArea = document.getElementById('comment-form-area');
        
        // 1. トリガーが無効な記事ではフォームを表示しない
        if (!ENABLE_COMMENT_TRIGGER) {
            formArea.innerHTML = '<p style="color: #888; text-align:center;">この記事では現在コメントを受け付けていません。</p>';
            return;
        }

        const currentState = localStorage.getItem(FLAG_STATE_KEY);

        if (currentState === 'COMPLETED') {
            // 2. 完了後の表示: 新しい記事が表示されたことを示唆
            formArea.innerHTML = '<p style="display: none;" id="timer-status"></p> ';
        } else if (currentState === 'PENDING') {
            // 3. 処理中の表示: メッセージを完全に削除し、何も表示しない
            formArea.innerHTML = `
                <p style="display: none;" id="timer-status"></p> 
            `;
            // 裏でタイマー監視自体は継続させる（重要）
            checkTriggerStatus(); 
        } else {
            // 4. 初期状態: フォームをレンダリング
            const formHtml = `
            <div id="comment-form-container" class="comment-entry-box"> 
        
                <p class="comment-meta"><strong>[ 投稿者: 匿名ユーザー]</strong></p>
                
                <form id="comment-form" onsubmit="handleCommentSubmit(event)">
                    
                    <textarea id="comment-text" name="comment" rows="3" placeholder="コメントを記入（50文字以内）" maxlength="50"></textarea>
                    <div class="button-container">
                        <button type="submit" id="comment-submit-button">コメントを送信</button>
                        
                        <p id="comment-message" class="comment-status-message" style="display: none; text-align: center;"></p>
                    </div>
                </form>
            </div>
            `;
            formArea.innerHTML = formHtml;
        }
    }

    // ---------------------------------------------------
    // 🔑 フォーム送信イベント処理 (タイムスタンプ記録)
    // ---------------------------------------------------
    
    function handleCommentSubmit(event) {
        event.preventDefault(); 
        
        const commentText = document.getElementById('comment-text').value.trim();
        const messageElement = document.getElementById('comment-message');
        
        if (commentText.length === 0) {
            messageElement.textContent = "コメントが記入されていません。";
            messageElement.style.color = 'red';
            messageElement.style.display = 'block';
            return;
        }

        // 1. 処理完了時刻を設定 (現在時刻 + 60秒)
        const ONE_MINUTE_MS = 60 * 1000;
        const triggerTime = Date.now() + ONE_MINUTE_MS; 
        
        // 2. Local Storageに状態を記録
        localStorage.setItem(FLAG_STATE_KEY, 'PENDING');
        localStorage.setItem(COMMENT_CONTENT_KEY, commentText);
        localStorage.setItem(TRIGGER_TIME_MS_KEY, triggerTime.toString());
        showNotification("コメントを送信しました。");

        if (!localStorage.getItem(TRIGGER_DATE_KEY)) {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            const dateToSave = `${year}-${month}-${day}`;
            
            localStorage.setItem(TRIGGER_DATE_KEY, dateToSave);
        }
        
        // 3. プレイヤーへのフィードバックとリロード
        messageElement.textContent = "";
        // messageElement.style.color = 'green';
        messageElement.style.display = 'block';
        
        // ページの表示を更新し、PENDING状態のタイマーを表示させる
        setTimeout(() => {
            window.location.href = window.location.href; 
        }, 1500);
    }
    
    // ---------------------------------------------------
    // 🔑 タイマー監視ロジック (完了チェック)
    // ---------------------------------------------------
    
    function checkTriggerStatus() {
        const statusElement = document.getElementById('timer-status');
        const currentState = localStorage.getItem(FLAG_STATE_KEY);
        const triggerTime = parseInt(localStorage.getItem(TRIGGER_TIME_MS_KEY), 10);

        if (currentState !== 'PENDING' || !triggerTime) {
            return;
        }

        console.log("--- Trigger System: PENDING ---");
        
        const updateTimer = () => {
            const now = Date.now();
            const remainingMs = triggerTime - now;

            if (remainingMs <= 0) {
                // 完了！状態をCOMPLETEDに更新し、リロード
                localStorage.setItem(FLAG_STATE_KEY, 'COMPLETED');
                clearInterval(timerInterval);
                console.log("--- Trigger System: COMPLETED. Reloading... ---");
                window.location.reload();
                return;
            }

            // 残り時間を計算して表示
            const remainingSeconds = Math.ceil(remainingMs / 1000);
            console.log(`Remaining time: ${remainingSeconds} seconds.`);
        };

        // 1秒ごとにタイマーを更新
        const timerInterval = setInterval(updateTimer, 10000);
        updateTimer(); // 即座に実行
    }


    // ページロード時にフォームをレンダリング
    document.addEventListener('DOMContentLoaded', renderCommentForm);

    // ---------------------------------------------------
    // 🔑 コンテンツ引用処理
    // ---------------------------------------------------

    function quoteCommentContent() {
        // 引用したい要素を取得
        const quoteElement = document.getElementById('quoted-comment-content');
        
        // コメント内容を取得
        const savedComment = localStorage.getItem(QUOTED_COMMENT_KEY);

        if (quoteElement && savedComment) {
            // 要素があれば、localStorageのコメントで内容を置き換える
            quoteElement.textContent = savedComment;
        }
    }

    // ---------------------------------------------------
    // 🔑 コメント履歴表示処理
    // ---------------------------------------------------

    function renderCommentHistory() {
        const historyContainer = document.getElementById('comment-history-area');
        const savedHistory = localStorage.getItem(COMMENT_CONTENT_KEY);
        const commentDateKey = `trigger_date_${BLOG_PATH}_${CURRENT_POST_SLUG}`;

        // 履歴が保存されていなければ何もしない
        if (!historyContainer || !savedHistory) {
            return;
        }
        
        // 履歴HTMLを生成
        const historyHtml = `
            <div style="margin-top: 20px; padding: 10px;">
                <div style="border-left: 3px solid #ccc; padding-left: 10px; margin-bottom: 10px;">
                    <p style="margin: 0;"><strong>1:匿名ユーザー</strong>
                    <p style="margin: 0;">投稿日：${localStorage.getItem(commentDateKey)}</p>
                    <p style="white-space: pre-wrap; margin: 5px 0 0 0;">${savedHistory}</p>
                </div>
            </div>
        `;
        
        historyContainer.innerHTML = historyHtml;
    }

    // ---------------------------------------------------
    // 🔑 通知ポップアップ表示処理
    // ---------------------------------------------------
    function showNotification(message) {
        const container = document.getElementById('notification-container');
        if (!container) return;

        // 1. 通知要素の生成
        const notification = document.createElement('div');
        notification.className = 'toast-notification';
        notification.textContent = message;

        // 2. コンテナに追加
        container.appendChild(notification);
        
        // 3. アニメーション: わずかに遅延させてクラスを追加し、スライドインさせる
        setTimeout(() => {
            notification.classList.add('show');
        }, 10); 

        // 4. 自動で消去: 3秒後にスライドアウトし、DOMから削除する
        setTimeout(() => {
            notification.classList.remove('show'); // スライドアウト開始
            
            // アニメーション完了後（0.5秒後）に要素をDOMから削除
            setTimeout(() => {
                notification.remove(); 
            }, 500); 
            
        }, 3000); // 3秒間表示
    }

    // 🎯 修正箇所 2: 引用元のトリガー記事の日付キーを再構築
    const QUOTE_DATE_KEY = `trigger_date_${BLOG_PATH}_${QUOTE_SLUG}`;

    function getDisplayDate() {
        // 隠し記事の場合は、トリガー記事の日付をチェック
        if (IS_HIDDEN_POST && QUOTE_SLUG) {
            const savedDate = localStorage.getItem(QUOTE_DATE_KEY);
            // 保存されていればその日付を返し、なければデフォルトを返す
            return savedDate || '---'; 
        }
        return ''; // 非隠し記事の場合は日付表示処理を行わない
    }

    function renderDynamicDate() {
        // 隠し記事の場合のみ実行
        if (!IS_HIDDEN_POST) {
            return; 
        }
        const dateElement = document.getElementById('dynamic-post-date');
        const displayDate = getDisplayDate();

        if (dateElement) {
            //永続化された日付を表示
            dateElement.textContent = `${displayDate}`;
        }
    }

    // ページロード時に実行されるように追加
    document.addEventListener('DOMContentLoaded', renderCommentForm);
    document.addEventListener('DOMContentLoaded', quoteCommentContent);
    document.addEventListener('DOMContentLoaded', renderCommentHistory);
    document.addEventListener('DOMContentLoaded', renderDynamicDate);// 👈 この行を追加

</script>
    </div>

    <footer>
        <p class="footer-note">
            このWebサイトの内容はフィクションであり、<br>
            実在の人物・団体とは一切関係ありません。
        </p>
        <p class="footer-copyright">&copy; 2025 出雲（@pearl_izumo）</p>
    </footer>

    <script>
        // 🔑 グローバル変数定義: Liquid変数の安全な参照
        const BASE_URL = ""; 
        const CURRENT_BLOG_PATH = "amaneblog"; // デフォルト値も設定
        //window.CURRENT_BLOG_PATH = "amaneblog";
        const PRIVATE_PATH = BASE_URL + "/" + CURRENT_BLOG_PATH + "/private/";
        console.log(PRIVATE_PATH);
        const AUTH_FLAG_KEY = `isAuthenticated_${CURRENT_BLOG_PATH}`;

        const AUTH_SETTINGS = {
            'amaneblog': {
                // パスワード情報
                password1: "MTk5NzAzMjQ=",
                password2: "ZmVlbHNwZWNpYWw=",
                // 質問情報
                question1: '・私の推しの誕生日は？',
                placeholder1: '西暦あり8桁',
                inputType1: 'text',
                question2: '・私の思い出の曲は？',
                placeholder2: '英語小文字',
                inputType2: 'text',
            },
            'hokanoblog': {
                // パスワード情報
                password1: "1st",
                password2: "2nd",
                // 質問情報
                question1: '・私の誕生日は？',
                placeholder1: '漢字3文字',
                inputType1: 'number',
                question2: '・秘密の合言葉は？',
                placeholder2: '全て大文字',
                inputType2: 'text', 
            },
            'default': {
                // デフォルト情報 (パスワードと質問)
                password1: "DEFAULT_1",
                password2: "DEFAULT_2",
                question1: '・認証コード 1/2',
                placeholder1: 'コード1を入力',
                inputType1: 'text',
                question2: '・認証コード 2/2',
                placeholder2: 'コード2を入力',
                inputType2: 'text',
            }
        };

        // 1. 認証に必要な設定を現在のブログパスから取得
        const currentSettings = AUTH_SETTINGS[CURRENT_BLOG_PATH] || AUTH_SETTINGS.default;

        // 2. 認証ロジックで使用するグローバル変数に代入
        const CORRECT_PASSWORD_1 = currentSettings.password1; 
        const CORRECT_PASSWORD_2 = currentSettings.password2;

        // 1. プレイヤーIDの生成と永続化 (コメントトリガー用)
        function getPlayerId() {
            let playerId = localStorage.getItem('arg_player_id');
            if (!playerId) {
                playerId = 'player-' + Math.random().toString(36).substring(2, 9);
                localStorage.setItem('arg_player_id', playerId);
            }
            return playerId;
        }

        getPlayerId(); 

        // 難読化
        function decodeBase64(encodedString) {
            // JavaScript標準のatob関数を使用
            return atob(encodedString); 
        }


        // 2. 汎用パスワード認証ロジック (2段階認証)
        function authenticate() {
            document.body.classList.add('is-locked');
            // フォームのHTMLを定義
            const formHtml = `
                <div id="auth-overlay" style="display: flex;">
                    <div id="auth-container">
                        <h2>非公開エリア</h2>
                        
                        <form id="password-form" onsubmit="handleAuthSubmit(event)">
                            <p>${currentSettings.question1}</p>
                            <input type="${currentSettings.inputType1}" id="auth-input-1" placeholder="--${currentSettings.placeholder1}" required>
                            <br>
                            <p>${currentSettings.question2}</p>
                            <input type="${currentSettings.inputType2}" id="auth-input-2" placeholder="--${currentSettings.placeholder2}" required>
                            
                            <button type="submit" id="auth-submit-button">ログイン</button>
                        </form>
                        
                        <p id="auth-message" style="display: none;">回答が間違っています。</p>
                        
                        <p style="margin-top: 20px; text-align: center;"><a href="${BASE_URL}/${CURRENT_BLOG_PATH}" style="color: var(--color-link);"> << ブログTOP</a></p>
                    </div>
                </div>
            `;

            // フォームを body の先頭に挿入 (afterbegin)
            const headerElement = document.querySelector('header');
            if (headerElement) {
                headerElement.insertAdjacentHTML('afterend', formHtml);
            } else {
                // header が見つからなければ body の先頭にフォールバック
                document.body.insertAdjacentHTML('afterbegin', formHtml);
            }
            
            // エラーを回避するため、要素が存在する場合にのみフォーカスを試みます
            const input1 = document.getElementById('auth-input-1');
            if (input1) {
                input1.focus(); 
            }
        }

        // フォーム送信時の処理
        function handleAuthSubmit(event) {
            event.preventDefault(); 
            
            const input1 = document.getElementById('auth-input-1').value.trim();
            const input2 = document.getElementById('auth-input-2').value.trim();
            const errorMessage = document.getElementById('auth-message');

            const decodedPassword1 = decodeBase64(CORRECT_PASSWORD_1);
            const decodedPassword2 = decodeBase64(CORRECT_PASSWORD_2);

            if (input1 === decodedPassword1 && input2 === decodedPassword2) {
                // 認証成功
                document.body.classList.remove('is-locked');
                localStorage.setItem(AUTH_FLAG_KEY, 'true');
                const overlay = document.getElementById('auth-overlay');
                if (overlay) { overlay.remove(); }
                
                
                window.location.href = window.location.href; 
            } else {
                // 認証失敗
                errorMessage.style.display = 'block';
                document.getElementById('auth-input-1').value = ''; 
                document.getElementById('auth-input-2').value = ''; 
                document.getElementById('auth-input-1').focus();
            }
        }

        // 3. アクセス制御の実行
        function checkPrivateAccess() {
            const currentPath = window.location.pathname;
            
            // 🔑 グローバル変数 PRIVATE_PATH を使用
            const isAuthenticated = localStorage.getItem(AUTH_FLAG_KEY) === 'true';
            const isPrivateArea = currentPath.startsWith(PRIVATE_PATH); 


            // 非公開エリアかつ未認証の場合
            if (isPrivateArea && !isAuthenticated) {
                
                authenticate(); // フォームを表示
                const mainContent = document.querySelector('.main-container');
                
            } else {
                // 認証済みまたは公開エリアの場合
                document.body.style.display = 'block'; 
            }
        }

        // ページロード時に実行
        checkPrivateAccess();

    </script>

</body>
</html>