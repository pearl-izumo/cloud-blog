<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>コメントトリガー記事 - 独白</title>
    <link rel="stylesheet" href="/assets/style.css">
</head>
<body>

    <header>
        <div class="header-content">
            <a href="/" class="logo-link">
                <img src="/assets/cloudblog_logo.png" alt="CLOUDBLOGロゴ" class="header-logo">
            </a>
        </div>
    </header>

    <div class="main-container">
        <article>
    <div id="notification-container"></div>
    <h1>コメントトリガー記事 - 独白</h1>
    <p>投稿日: 2025年10月12日</p>

    <div class="post-content">
        <p>この記事にコメントすると、アマネからの反応が時間差で表示されます。</p>

<p>【注意】 このファイルには、次のステップでコメントトリガーのJavaScriptロジックが追加されます。</p>

    </div>

    <hr style="margin-top: 40px;">
    
    <section id="comment-section">
        <h2>:: コメント / 記録 ::</h2>
        
        <div id="comment-form-area">
            <p>システムを読み込み中...</p>
        </div>
        
        <div id="comment-history-area">
            <p style="color: #666;">（現時点で書き込まれた記録はありません。）</p>
        </div>

    </section>

    <style>
        /* 通知コンテナの基本スタイル */
        #notification-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000; /* 他の要素の上に表示 */
            pointer-events: none; /* クリックを透過させる */
        }
    
        /* 個別通知のスタイル */
        .toast-notification {
            background-color: #4CAF50; /* 緑色の背景 */
            color: white;
            text-align: center;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            
            /* 画面外に隠すための初期位置 */
            transform: translateY(-100%); 
            transition: transform 0.5s ease-in-out; /* アニメーションの設定 */
            
            /* 中央寄せのための設定 */
            margin: 0 auto;
            max-width: 400px;
            border-bottom-left-radius: 5px;
            border-bottom-right-radius: 5px;
        }
    
        /* 表示時のスタイル */
        .toast-notification.show {
            transform: translateY(0); /* 画面内にスライドイン */
        }
    </style>

</article>

<script>
    const CURRENT_PLAYER_ID = localStorage.getItem('arg_player_id') || 'unknown';
    const CURRENT_POST_SLUG = "betsunoblog-trigger-test";
    const ENABLE_COMMENT_TRIGGER = "true" === 'true';

    // 🔑 ローカルストレージで使用するキーの定義
    const FLAG_STATE_KEY = 'arg_flag_state';      // 状態: PENDING / COMPLETED
    const COMMENT_CONTENT_KEY = 'arg_comment_content'; // プレイヤーのコメント内容
    const TRIGGER_TIME_MS_KEY = 'arg_trigger_time_ms'; // 処理完了予定時刻 (UNIX時間)

    // ---------------------------------------------------
    // 🔑 コメントフォーム生成と表示
    // ---------------------------------------------------
    
    function renderCommentForm() {
        const formArea = document.getElementById('comment-form-area');
        
        // 1. トリガーが無効な記事ではフォームを表示しない
        if (!ENABLE_COMMENT_TRIGGER) {
            formArea.innerHTML = '<p style="color: #888;">（この記録はシステムによるロックアップ中です。）</p>';
            return;
        }

        const currentState = localStorage.getItem(FLAG_STATE_KEY);

        if (currentState === 'COMPLETED') {
            // 2. 完了後の表示: 新しい記事が表示されたことを示唆
            formArea.innerHTML = '<p style="display: none;" id="timer-status"></p> ';
        } else if (currentState === 'PENDING') {
            // 3. 処理中の表示: メッセージを完全に削除し、何も表示しない
            formArea.innerHTML = `
                <p style="display: none;" id="timer-status"></p> 
            `;
            // 裏でタイマー監視自体は継続させる（重要）
            checkTriggerStatus(); 
        } else {
            // 4. 初期状態: フォームをレンダリング
            const formHtml = `
                <div style="border: 1px solid #ccc; padding: 15px; margin-bottom: 20px;">
                    <p><strong>[ 投稿者: ${CURRENT_PLAYER_ID} ]</strong></p>
                    <form id="comment-form" onsubmit="handleCommentSubmit(event)">
                        <textarea id="comment-text" name="comment" rows="4" placeholder="記録を書き込む..." style="width: 98%; padding: 5px; margin-bottom: 10px;"></textarea>
                        <button type="submit" style="padding: 8px 15px;">記録を送信</button>
                        <p id="comment-message" style="color: green; margin-top: 10px; display: none;"></p>
                    </form>
                </div>
            `;
            formArea.innerHTML = formHtml;
        }
    }

    // ---------------------------------------------------
    // 🔑 フォーム送信イベント処理 (タイムスタンプ記録)
    // ---------------------------------------------------
    
    function handleCommentSubmit(event) {
        event.preventDefault(); 
        
        const commentText = document.getElementById('comment-text').value.trim();
        const messageElement = document.getElementById('comment-message');
        
        if (commentText.length === 0) {
            messageElement.textContent = "記録内容が空です。";
            messageElement.style.color = 'red';
            messageElement.style.display = 'block';
            return;
        }

        // 1. 処理完了時刻を設定 (現在時刻 + 60秒)
        const ONE_MINUTE_MS = 60 * 1000;
        const triggerTime = Date.now() + ONE_MINUTE_MS; 
        
        // 2. Local Storageに状態を記録
        localStorage.setItem(FLAG_STATE_KEY, 'PENDING');
        localStorage.setItem(COMMENT_CONTENT_KEY, commentText);
        localStorage.setItem(TRIGGER_TIME_MS_KEY, triggerTime.toString());
        showNotification("コメントを送信しました。");
        
        // 3. プレイヤーへのフィードバックとリロード
        messageElement.textContent = "";
        messageElement.style.color = 'green';
        messageElement.style.display = 'block';
        
        // ページの表示を更新し、PENDING状態のタイマーを表示させる
        setTimeout(() => {
            window.location.href = window.location.href; 
        }, 1500);
    }
    
    // ---------------------------------------------------
    // 🔑 タイマー監視ロジック (完了チェック)
    // ---------------------------------------------------
    
    function checkTriggerStatus() {
        const statusElement = document.getElementById('timer-status');
        const currentState = localStorage.getItem(FLAG_STATE_KEY);
        const triggerTime = parseInt(localStorage.getItem(TRIGGER_TIME_MS_KEY), 10);

        if (currentState !== 'PENDING' || !triggerTime) {
            return;
        }

        console.log("--- Trigger System: PENDING ---");
        
        const updateTimer = () => {
            const now = Date.now();
            const remainingMs = triggerTime - now;

            if (remainingMs <= 0) {
                // 完了！状態をCOMPLETEDに更新し、リロード
                localStorage.setItem(FLAG_STATE_KEY, 'COMPLETED');
                clearInterval(timerInterval);
                console.log("--- Trigger System: COMPLETED. Reloading... ---");
                window.location.reload();
                return;
            }

            // 残り時間を計算して表示
            const remainingSeconds = Math.ceil(remainingMs / 1000);
            console.log(`Remaining time: ${remainingSeconds} seconds.`);
        };

        // 1秒ごとにタイマーを更新
        const timerInterval = setInterval(updateTimer, 10000);
        updateTimer(); // 即座に実行
    }


    // ページロード時にフォームをレンダリング
    document.addEventListener('DOMContentLoaded', renderCommentForm);

    // ---------------------------------------------------
    // 🔑 コンテンツ引用処理
    // ---------------------------------------------------

    function quoteCommentContent() {
        // 引用したい要素を取得
        const quoteElement = document.getElementById('quoted-comment-content');
        
        // コメント内容を取得
        const savedComment = localStorage.getItem(COMMENT_CONTENT_KEY);

        if (quoteElement && savedComment) {
            // 要素があれば、localStorageのコメントで内容を置き換える
            quoteElement.textContent = savedComment;
        }
    }

    // ---------------------------------------------------
    // 🔑 コメント履歴表示処理
    // ---------------------------------------------------

    function renderCommentHistory() {
        const historyContainer = document.getElementById('comment-history-area');
        const savedHistory = localStorage.getItem(COMMENT_CONTENT_KEY);
        
        const currentPostSlug = "betsunoblog-trigger-test"; // Liquidの変数を使用
        const triggerPostSlug = "amaneblog-trigger-test"; // 🔑 トリガー記事のスラッグに合わせる

        // 履歴が保存されていなければ何もしない
        if (!historyContainer || !savedHistory) {
            return;
        }
        // 🔑 修正の核: 現在の記事がトリガー記事でない場合、履歴を表示しない
        if (currentPostSlug !== triggerPostSlug) {
            return;
        }
        
        // 履歴HTMLを生成
        const historyHtml = `
            <div style="margin-top: 20px; padding: 10px; border-top: 1px solid #ddd;">
                <p style="font-weight: bold; margin-bottom: 5px;">--- 記録履歴 ---</p>
                <div style="border-left: 3px solid #ccc; padding-left: 10px; margin-bottom: 10px;">
                    <p style="margin: 0;"><strong>[${CURRENT_PLAYER_ID}] </strong>${new Date().toLocaleString()}</p>
                    <p style="white-space: pre-wrap; margin: 5px 0 0 0;">${savedHistory}</p>
                </div>
            </div>
        `;
        
        historyContainer.innerHTML = historyHtml;
    }

    // ---------------------------------------------------
    // 🔑 通知ポップアップ表示処理
    // ---------------------------------------------------
    function showNotification(message) {
        const container = document.getElementById('notification-container');
        if (!container) return;

        // 1. 通知要素の生成
        const notification = document.createElement('div');
        notification.className = 'toast-notification';
        notification.textContent = message;

        // 2. コンテナに追加
        container.appendChild(notification);
        
        // 3. アニメーション: わずかに遅延させてクラスを追加し、スライドインさせる
        setTimeout(() => {
            notification.classList.add('show');
        }, 10); 

        // 4. 自動で消去: 3秒後にスライドアウトし、DOMから削除する
        setTimeout(() => {
            notification.classList.remove('show'); // スライドアウト開始
            
            // アニメーション完了後（0.5秒後）に要素をDOMから削除
            setTimeout(() => {
                notification.remove(); 
            }, 500); 
            
        }, 3000); // 3秒間表示
    }

    // ページロード時に実行されるように追加
    document.addEventListener('DOMContentLoaded', renderCommentForm);
    document.addEventListener('DOMContentLoaded', quoteCommentContent);
    document.addEventListener('DOMContentLoaded', renderCommentHistory); // 👈 この行を追加

</script>
    </div>

    <footer>
        <p class="footer-note">
            このWebサイトの内容はフィクションであり、<br>
            実在の人物・団体とは一切関係ありません。
        </p>
        <p class="footer-copyright">&copy; 出雲（@pearl_izumo）</p>
    </footer>

    <script>
        // 🔑 グローバル変数定義: Liquid変数の安全な参照
        const BASE_URL = ""; 
        const PRIVATE_PATH = BASE_URL + "/private/";
        
        // 2段階パスワードを取得 (デフォルト値で安全化)
        //const CORRECT_PASSWORD_1 = "AMANE-SECRET-KEY";
        //const CORRECT_PASSWORD_2 = "CLOUD-HIDDEN-WORD";
        const CORRECT_PASSWORD_1 = "1st";
        const CORRECT_PASSWORD_2 = "2nd";


        // 1. プレイヤーIDの生成と永続化 (コメントトリガー用)
        function getPlayerId() {
            let playerId = localStorage.getItem('arg_player_id');
            if (!playerId) {
                playerId = 'player-' + Math.random().toString(36).substring(2, 9);
                localStorage.setItem('arg_player_id', playerId);
            }
            return playerId;
        }

        getPlayerId(); 


        // 2. 汎用パスワード認証ロジック (2段階認証)
        function authenticate() {
            // フォームのHTMLを定義
            const formHtml = `
                <div id="auth-overlay" style="
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0, 0, 0, 0.9); z-index: 10000; 
                    display: flex; 
                    justify-content: center; align-items: center; 
                    flex-direction: column; color: white;
                ">
                    <h2>【二重認証が必要です】</h2>
                    <p>非公開エリアへ入るための **合言葉** と **秘密の数字** を入力してください。</p>
                    <form id="password-form" onsubmit="handleAuthSubmit(event)">
                        <input type="text" id="auth-input-1" placeholder="合言葉 (例: AMANE-SECRET-KEY)" style="padding: 8px; margin: 5px; width: 250px;">
                        <input type="text" id="auth-input-2" placeholder="秘密の数字 (例: CLOUD-HIDDEN-WORD)" style="padding: 8px; margin: 5px; width: 250px;">
                        <button type="submit" style="padding: 8px 15px; margin-top: 10px;">認証を試みる</button>
                    </form>
                    <p style="margin-top: 20px;"><a href="${BASE_URL}/" style="color: #ccc;">[ ブログ入口に戻る ]</a></p>
                    <p id="error-message" style="color: red; margin-top: 10px; display: none;">合言葉または秘密の数字が違います。</p>
                </div>
            `;

            // フォームを body の先頭に挿入 (afterbegin)
            document.body.insertAdjacentHTML('afterbegin', formHtml);
            
            // エラーを回避するため、要素が存在する場合にのみフォーカスを試みます
            const input1 = document.getElementById('auth-input-1');
            if (input1) {
                 input1.focus(); 
            }
        }

        // フォーム送信時の処理
        function handleAuthSubmit(event) {
            event.preventDefault(); 
            
            const input1 = document.getElementById('auth-input-1').value.trim();
            const input2 = document.getElementById('auth-input-2').value.trim();
            const errorMessage = document.getElementById('error-message');

            if (input1 === CORRECT_PASSWORD_1 && input2 === CORRECT_PASSWORD_2) {
                // 認証成功
                localStorage.setItem('isAuthenticated', 'true');
                const overlay = document.getElementById('auth-overlay');
                if (overlay) { overlay.remove(); }
                
                window.location.href = window.location.href; 
            } else {
                // 認証失敗
                errorMessage.style.display = 'block';
                document.getElementById('auth-input-1').value = ''; 
                document.getElementById('auth-input-2').value = ''; 
                document.getElementById('auth-input-1').focus();
            }
        }

        // 3. アクセス制御の実行
        function checkPrivateAccess() {
            const currentPath = window.location.pathname;
            
            // 🔑 グローバル変数 PRIVATE_PATH を使用
            const isPrivateArea = currentPath.startsWith(PRIVATE_PATH); 
            const isAuthenticated = localStorage.getItem('isAuthenticated') === 'true';

            // 非公開エリアかつ未認証の場合
            if (isPrivateArea && !isAuthenticated) {
                
                authenticate(); // フォームを表示

                // 修正済み: bodyの構成要素を個別に非表示にする
                document.body.style.display = 'block'; 
                
                const elementsToHide = ['header', '.container', 'footer'];
                elementsToHide.forEach(selector => {
                    const element = document.querySelector(selector);
                    if (element) {
                        element.style.display = 'none';
                    }
                });
                
            } else {
                // 認証済みまたは公開エリアの場合
                document.body.style.display = 'block'; 
            }
        }

        // ページロード時に実行
        checkPrivateAccess();

    </script>

</body>
</html>